%************************************************
\chapter{Introduction to RNA design}\label{ch:mathtest} % $\mathbb{ZNR}$
%************************************************
The previous chapters demonstrated the implications of non-coding RNA molecules in varying levels of cellular processes, from gene expression regulation (miRNAs, piRNAs, lncRNAs) to RNA maturation (snRNAs, snoRNAs) and protein synthesis (rRNAs, tRNAs). Knowing that those biological functions are performed by high dimensional RNA structures which strongly depend on their secondary structures,  we also provided a broad review on computation methods for predicting secondary structures. Now, supposing that we have computational folding tools that are accurate enough, is it possible to design an RNA molecule that is able to accomplish a desired biological function for a given secondary structure? Answering this question may demands both experimental and computational efforts. For artificial non-coding RNAs for which the native RNA sequence is unknown, the key prerequisite for experimentalist is often a computational solution to the inverse folding problem. Unlike the folding problem, here, the secondary structure is given and the goal is to find one or many  RNA sequences that fold into that secondary structure. This chapter aim at giving the biological motivation and biotechnological implications of addressing this problem. Then, it provides a brief literature review on the existing computational methods. 

\section{RNA inverse folding and biotechnological implications}  
\graffito{You might get unexpected results using math in chapter or
section heads. Consider the \texttt{pdfspacing} option.}

In modern biotechnology, we often seek to reproduce the natural ability of the cells to control gene expressions using a variety of nucleic acids and proteins. These natural cellular abilities are the result of networks of regulatory molecules such as ncRNAs that dynamically control the expression of specific genes in response to environmental signals. Therefore, the ability to engineer biological systems is directly related to controlling gene expression. The increasing number of examples of natural regulator ncRNAs has opened doors to many emerging subfields such as RNA synthetic biology \cite{chappell2015renaissance, isaacs2006rna} and RNA nanostructure \cite{jaeger2001tectorna, guo2010emerging}. Researchers have engineered RNA molecules with new biological functions, inspired by this natural versatility. Synthetic biology has also made great progress in developing versatile and programmable genetic regulators that enable the precise control of gene expressions in the last decades. Three general approaches are taken to engineer new functional RNAs: harvesting from nature, computational design and molecular evolution. We are interested here in computational design methods.

In most cases, designing a functional RNA goes beyond computationally generating a set of RNA sequence that fold into a given structure. Successful design methods include computational and experimental, predictive and analytical methods. However, computational tools addressing the inverse folding problem often provide some guidances and rationalities through the design process. For example, Steffen Mueller and his collaborators \cite{mueller2010live} suggested a systematic, rational approach, termed Synthetic Attenuated Virus Engineering (SAVE), to develop new, efficacious live attenuated influenza virus vaccine candidates using computer-aided rational design. In addition, Eckart Bindewald et al. \cite{bindewald2011multistrand} used computational tools for solving inverse RNA folding in the design of nanostructures  including pseudoknots and in designing several ncRNAs with successful synthetic such as ribozymes \cite{dotu2014complete}, riboswitches \cite{findeiss2015design,wachsmuth2015design}. 

\section{The positive and negative design.}
We often find in the literature, two different types of design problem of RNAs: a positive design and a negative design. 
The negative structural design of RNAs, also called the inverse RNA folding problem for which the goal is to find one or many RNA sequences that fold into a given target RNA secondary structure while avoiding alternative folds of similar quality for
the chosen energy model $E$. In other terms, it is an optimization problem where a target RNA secondary structure $\sigma^*$ of length $L$ is given, and the goal is to determine an RNA sequence $\phi$ of length $L$ such that $\forall \sigma \neq \sigma^* \in \Gamma_{\phi}$, $E(\phi, \sigma) > E(\phi, \sigma^*)$ .

This problem has been shown to be NP-hard even in a simple energy model \cite{bonnet2020designing} and we can not provide a parametrized algorithm that solves it in a polynomial time. 

In contrast, a positive design problem consists of optimizing affinity towards a given target secondary structure. In another terms, the objective is the find a sequence $\phi \in \{A,U,C,G\}^L$ such that  $ \sigma^*=\sigma^{MFE}(\phi) = \arg \min_{\sigma \in \Gamma_{\phi}} E(\phi, \sigma)$ (i.e. the sequence $\phi$ should have as MFE structure of its ensemble $\Gamma_{\phi}$ the target structure $\sigma^*$). The positive design is computationally solvable exactly in a polynomial timeÂ \cite{flamm2001design}. 

Both negative and positive designs are considered in this work, and the main different often depends on the objective function used. In addition, it has be shown more recently that the proportion of designable secondary structures decreases exponentially with $L$, for various popular combinations of energy models and design objectives \cite{yao2019exponentially}.


\section{Objective functions previously used in the context of Inverse RNA folding.}

For a given target secondary structure of length $L$, a brute force approach to the inverse RNA folding problem that enumerates all possible RNA sequence is no viable due to the exponential growth of the search space (i.e. $4^L$). For the space of compatibles sequences to the target $\sigma^*$, an upper bound can be refined by restricting the paired position to the valid base pairs: G-C, G-U, and A-U. This results to $6^{(L-u)/2} \times 4^u$ sequences compatible with $\sigma^*$ where $u$ is the number of unpaired nucleotides. In practice, the most common way to efficiently handle the huge set of possible solutions is to solve an optimization problem subjected to a formulated objective function. There exists a variety of well-established optimization methods helping to perform this task. However, finding the right objective function to evaluate the solutions can be quite challenging. 

The objective function defines a mathematical model that maps each RNA sequence solution to its important properties or functions. In biological terms this relation between fitness and sequence can be seen as an assignment of a phenotype (score) to a genotype (sequence). Selection pressure due to the optimization method ensures that better phenotypes are advantageous and thus preferred, which optimizes the sequence to fall into fitness optima. This section will provide the definition of the objective functions previously used in the RNA design problems and highlight some of their interesting properties.

\begin{itemize}
	%\tightlist
	\item
	A simple distance from the target structure: since the main goal of the inverse folding problem is to find sequences that fold into a given target secondary structure~\(\sigma*\), in the simplest setting the objective function of an RNA sequence~\(\phi\) is defined as the structure distance between $\sigma^*$ and the current MFE structure $\sigma_{MFE} (\phi)$. This often requires only the computation the MFE structure, hence being computationally fast. There are many variants of this distance measure: base-pair distance, hamming or string edit distance, tree-edit distance and energy distance. For formal definition of each of those distances measure see Section \ref{sec:rna_biochemical}. This objective function was used in the earliest tools such as \texttt{RNAinverse} \cite{hofacker1994fast} but also in many others since then \cite{andronescu2004new, busch2006info, gao2010inverse} . 
	
	\item A negative design objective function: in contrast to the above mention objective functions (often considered when performing a positive design), the whole structural ensemble is considered here when computing the fitness of an RNA sequence $\phi$. In most cases, it is preferable to also consider negative design goals which allow avoiding alternative structures in of similar quality of the target structure.
	
	The avoidance of alternative structures is often termed by a notion of defect. Negative RNA design methods
	usually consider one of the three following defects: (1)  the \textit{suboptimal defect} \cite{hofacker1994fast, flamm2001design, dirks2003partition, zadeh2011nupack} which defines the energy distance to the first suboptimal (2) the \textit{probability defect} \cite{zadeh2011nupack, hofacker1994fast} which defines the probability that the sequence $\phi$ folds into any other structure than the target structure $\sigma^*$  and (3) the \textit{ensemble defect} \cite{zadeh2011nupack} which corresponds to the average number of incorrectly paired nucleotides at equilibrium calculated over the structure ensemble of $\phi$, $\Gamma_{\phi}$. 
	
	\item Multi-objective optimization: in some designing cases where more that one goal is specified, it is necessary to formulate an objective function for each goal. That result to a multi-objective optimization problem.  The solutions of such problems are all optimal with respect to at least one objective function and thus arranged on the so-called Pareto optimal front. This approach has already been used in several RNA design tools such as \texttt{Modena} \cite{modena_2012, taneda2015multi} and in \cite{ramlan2011design}.
	
	\item Bistable and multi-stable riboswitches objective functions: In some designing cases, especially for riboswitches, it is possible to specify more than one desired target structure including the energy differences between them, the barrier heights and the kinetic properties. Following the same idea, Flamm et al introduced for the first time an objective function that enables designing RNA molecules that can adopt two distinct structures \cite{flamm2001design}. This bistable objective function contains two terms. The first term increases the probability of both structures in the ensemble and the second one specifies the desired energy difference between both states. It is also possible to vary the temperature of the states in order to gain a bistable thermoswitch. The same idea has therefore been expanded to an objective function for designing RNA molecules that can adopt more than two structures, including extension for multi-structure energy barrier calculations (See Definition \ref{}, \ref{} for more details) \cite{ramlan2011design, shu2010ardesigner}.  \texttt{Frnakenstein} \cite{lyngso2012frnakenstein} also utilises such objective function for multi-target design.
	
	\item Mutational robustness and neutrality: The size of the RNA structural ensemble has been analytically computed through tools developed by Stein and Waterman \cite{stein1979some}, and it yields an upper bound of~\(S_L\approx1.48\times L^{-\frac{3}{2}}1.85^L\) structure vis-a-vis~\(4^L\) sequences.
	Compared to the total number of sequences, the number of structures is much smaller, which means there is indeed a high possibility that many sequences fold into the same structure. In case that happens, the set of those sequences are said to be neutral. Therefore, a neutral network of RNA sequences is a graph in which vertices are neutral sequences and, two vertices are adjacent when they differ by a single nucleotide. In addition to the above-mentioned objective functions, there are objective functions that aim at measuring the mutual neutrality of the sequence concerning the target structure \cite{shu2010ardesigner}. When using such objective function, the sequences are optimized in a way the fraction of one-mutant neighbours to the original structure is as big as possible. This allow to perfectly preserve the structure when mutation are introduce. We often talk of a mutational robustness optimization \cite{avihoo2011rnaexinv}.
	
\end{itemize}



\section{A review on existing inverse RNA folding tools.}

Several methods or algorithms addressing this problem have been proposed in the literature. The existing methods can be classified into two categories: one that deals with pseudoknot-free structure design and the another one for the pseudoknotted RNA structure design.  

\subsection{Pseudoknot-free RNA inverse folding tools}
Due to the complexity of the RNA design,  most of the existing tools perform a stochastic search optimization where initial potential solutions are generated and, refined over a finite number of iterations or generations \cite{esmaili2015erd, dromi2008reconstruction,esmaili2014evolutionary,taneda2011modena,nemo2018}.

Among the existing tools, both \texttt{ERD} \cite{esmaili2014evolutionary, esmaili2015erd} and \texttt{MODENA} \cite{modena_2012} are evolutionary algorithms but implementing different strategies. \texttt{MODENA} uses a multi-objective function that measures the stability of the folded sequence and its similarities to the target. It starts from a population of randomly generated sequences, and the objective is optimized through tournament selection and random mutation at non-closing loop positions. In contrast, \(\texttt{ERD}\) starts by decomposing the target structure into loops and independently uses an evolutionary algorithm to minimize each constituent's energy. It was first developed in 2014Â \cite{esmaili2014evolutionary}, and one year after, an updated version was released \cite{esmaili2015erd}. The main lines of \texttt{ERD} are:
\begin{enumerate}
\item Pool reconstruction: using a collection of RNA sequences (STRAN database) similar to the natural ones, a pool of sequences is constructed with respect to their length by successively finding the corresponding structure using \texttt{RNAfold}, decomposing the structure in sub-components, and finally, the corresponding sub-sequences of the same size are gathered to form a pool. 
\item Hierarchical decomposition of the target structure into loops: using the idea that any secondary structure can be uniquely decomposed into its structural components (stems, hairpin loops, internal loops, bulge and multi-loops), \texttt{ERD} decomposes the target in the positions where multi-loops occur. 
\item Sequence initialization: after decomposing the target structure into sub-components, Â for each sub-component, a random sub-sequence is chosen from the pool, and the initial sequence is a combination of those sub-sequences; 
\item Evolutionary optimization of the sub-sequences: An evolutionary algorithmÂ is performed on each sub-component to improve the initial sequence. The outcome sub-sequences are combined to form a newer sequence that will replace the initial one. Â Iteratively the evolutionary algorithm is performed on the updated sequence until the combined sequence folds into the target or in a failure case when the stopping condition is satisfied. Two evolutionary operators are implemented here, a mutation that consists of replacing a sub-sequence corresponding to a sub-component with a new random one from the pool with respect to the length, and a selection which consists of choosing from a population of 15 RNA sequences or sub-sequences, three best sequences with respect to their free energy and adding them to the best from the preview generation, three best ones with respect to the Hamming distance from the target are therefore chosen. Â The next-generation population is then obtained by generating for each of the three best sequences five new sequences.
\end{enumerate}
Â 
Some algorithms implement different strategies from the population-based approach. 

\texttt{sentRNA} \cite{shi2018sentrna} is a computational agent that uses a set of information and strategies collected from the \texttt{EteRNA} game players to train a neural network model. The neural network assigns an identity of A, U, C, or G to each position in the given target a featurized representation of its local environment. The featurised representation is a combination of information about its bonding partner, nearest neighbors, and long-range features. While the bonding partner and nearest neighbor information is provided to the agent by default, long-range features are learned through the training data. For each target structure, the long-range features refer to important position $j$ relative to $i$ that the agent should also have knowledge of when deciding what nucleotide to assign to $i$. These are defined by two values: the Cartesian distance and the angle in radians. Those two values are computed for each position $(i,j)$ using a mutual information metric over the player solution dataset. The result is therefore a list of long-range features for a given target structure.  By randomly selecting a subset of long-features is then selected from this list and used to define a model to be used for training, validation, and testing of the neural network model.  In addition to the neural network model, \texttt{sentRNA} also implements a refinement algorithm on the unsuccessful design. the refinement algorithm is a adaptive walk that start from the predicted sequence and uses a set of random mutations that allow to improve the neural network solution. Alternatively, \texttt{EternaBrain} \cite{koodli2019eternabrain} implement a convolutional network model trained on a huge eternamoves-select repository of $30,477$ moves from the top $72$ players; and \texttt{LeaRNA}\cite{runge2018learning} uses deep reinforcement learning to train a policy net-
work to sequentially design an entire RNA sequence given a specified target structure.

\texttt{NEMO} \cite{nemo2018} is a recently developed tool combining a Nested Monte Carlo Search (NMCS) technique with domain-specific knowledge to create a novel algorithm. The underlying idea is to start with an input pattern sequence of N's of the same length as the targeted structure. First, it uses the standard NMCS to sample sequence solutions acting on N's only. A sequence candidate is selected from the sample; then, the sequence is folded into an MFE structure. When the MFE structure does not match the targeted one, some subset mutations are performed, and a set of random mutated positions are picked to generate a new input pattern sequence that will allow sampling acting on N's only using the same standard NMCS. This procedure is then repeated several times until the MFE structure matches the targeted structure or not in the unsuccessful cases. The statistical results show that \texttt{NEMO} surpasses all the existing tools on the \texttt{EteRNA100} benchmark datasets by solving $\approx95\%$ of the targets using the Turner1999 energy parameter sets. Using similar technique, \texttt{RNAinverse}\cite{lorenz2011viennarna}, one of the oldest inverse folding tool included in the \texttt{ViennaRNA} package, uses an adaptive random walk to minimize base pair distance.  The distance is computed by comparing the MFE folding of the mutated sequence with the target structure. In addition, \texttt{RNAinverse} allows designing sequences that are more probable using the partition function optimization. The later allows to design more stable sequences but mostly different from the target structure. On an attempt to improve \texttt{RNAinverse}, many other tools have been suggested \texttt{INFO-RNA}Â \cite{busch2006info}, \texttt{RNA-SSD} \cite{andronescu2004new} and \texttt{DSS-Opt} \cite{matthies2012dynamics}. The most recent tools also include \texttt{RNAPOND} \cite{yao2021taming} and \texttt{MaiRNAiFold} \cite{minuesa2021moirnaifold}.

\(\texttt{antaRNA}\)~\cite{kleinkauf2015antarna} is also a recent program available since 2015, and it provides a web server for a friendly usability. It utilizes an \textit{ant-colony} optimization, in which an initial sequence is generated via a weighted random search, and the \textit{fitness} of that sequence is then used to refine the weights and improve subsequences over generations. It provides many other interesting features such as, the sequence constraint and the target GC-content constraint.  It also provides a fast python script that includes the options from the web server presented through a command line. This dual advantage is also provided by other tools but they implement different optimization techniques. \(\texttt{NUPACK:design}\) \cite{zadeh2011nucleic} uses a tree decomposition technique and the ensemble defect as objective function to design qualitatively good sequences.
\texttt{incaRNAfbinv} \cite{drory2016incarnafbinv} is a program for fragment-based RNA design. \texttt{incaRNAfbinv}'s web server combines two complementary methodologies: \(\texttt{IncaRNAtion}\) \cite{reinharz2013} and \texttt{RNAfbinv} \cite{weinbrand2013rnafbinv}. \(\texttt{IncaRNAtion}\) generates a GC-weighted partition function for the target structure, and then adaptively samples sequences from it to match the desired GC-content. \(\texttt{RNAiFold}\) \cite{garcia2013rnaifold}~employs constraint programming that exhaustively searches over all possible sequences compatible with a given target. \(\texttt{RNAiFold}\) \cite{garcia2013rnaifold} has the particularity of  designing synthetic functional RNA molecules.  


\subsection{Pseudoknotted RNA inverse folding tools}
Designing sequences for a pseudoknotted target structure is computationally more expensive than a pseudoknot-free target because of the complexity of the folding algorithms required. For that reason, many of the studies addressing the inverse folding of RNA considered only pseudoknot-free secondary structures. There are, however, some exceptions: \texttt{MCTS-RNA} \cite{yang2017rna}, \texttt{antaRNA}\cite{kleinkauf2015antarna}, \texttt{Modena} and \texttt{Inv}\cite{gao2010inverse}.
 
 \texttt{Inv} was one of the first inverse folding tools handling pseudoknotted RNA target structures, but was restricted to a specific type of pseudoknot pattern called $3$-crossing nonplanar pseudoknots.
 
 More recently, \texttt{MCTS-RNA} was suggested and it handled a broader type of pseudoknots. It uses a Monte Carlo tree search (MCTS) technique which has recently  shown exceptional performance in Computer Go.The MCTS allows initialising a set of RNA sequence solutions in \texttt{MCTS-RNA} and the solutions are further improved through local update at the nucleotide positions.
 
 Another approaches (\texttt{Modena}, \texttt{antaRNA}) implements different strategies one which is a multi-objective \texttt{ant-colony} optimisation and the another one which is a multi-objective evolutionary algorithm.  Although the first versions were implemented for pseudoknot-free structure \cite{taneda2011modena, kleinkauf2015antarna}, they have since been extended to support pseudoknotted RNAs \cite{modena_2012, kleinkauf2015antarna2}. 
 
  \texttt{MCTS-RNA} uses \texttt{pkiss} as folding tool whereas the other tools (\texttt{antaRNA} and \texttt{Modena}) support a broader range of folding tools such as \texttt{HotKnots} or \texttt{IPKnot}. 
 
\section{Benchmarking the Inverse folding tools}
In general, to evaluate the RNA design tools' performance, we use benchmark datasets \cite{churkin2017design}. Two benchmark datasets are mostly used in the literature---$(i)$ Rfam\footnote{The Rfam database \url{https://rfam.xfam.org/}}: a collection of RNA families, each represented by multiple sequence alignments, consensus secondary structures and covariance models---$(ii)$ \texttt{EteRNA100}: a collection of hundred RNA secondary structures extracted from the EteRNA Puzzle game\footnote{The EteRNA game \url{https://eternagame.org/}}. The EteRNA game is built on an old version of \texttt{ViennaRNA} package that used the Turner1999 energy parameter sets~\cite{Turn1999}. When the benchmark datasets rely on a particular energy parameter set, the performance of a given inverse RNA folding tool evaluated on these datasets will also be related to the choice of the RNA folding tool's energy parameter set. In case the benchmark datasets do not rely on a particular energy parameter set, the robustness of the inverse RNA tool will be its capability to perform well on different energy parameter sets.

\section{Conclusion}
In summary, the RNA inverse folding problem is still a challenging task to solve and it finds many application in RNA synthetic, RNA nanostructure design, and in emerging field such as Bioengineering and new biotechnology innovations. We introduced in this chapter, a rich literation review on existing computational methods that addressed this problem. The existing approaches have some advantages and disadvantages, depending on the techniques implemented. \(\texttt{NUPACK}\) for example---despite its well-defined objective function---still has difficulty designing sequences for large targets and most of the \(\texttt{EteRNA100}\) targets. In contrast, \(\texttt{ERD}\) because of its strong decomposition method which allows to deal quickly with large targets (On Rfam 1.0 with target's length between~\(400-1400\)) but still a big challenge to solve more than~\(65\%\)~of the~\(\texttt{EteRNA100}\) using the Turner2004 energy parameter sets. On another side,~\(\texttt{NEMO}\), one of the most recent tools, can solve more than~\(90\%\)~of~ the \(\texttt{EteRNA100}\) dataset using an old version of \texttt{ViennaRNA} package, which is based on Turner1999 energy parameter sets~\cite{Turn1999}. The \texttt{sentRNA}'s machine learning model also relied on the same old version of \texttt{ViennaRNA} package and, by adding a refinement on the machine learning model, \texttt{sentRNA} solves~\(78\%\)~of~\(\texttt{EteRNA100}\). Without this refinement,~\(\texttt{sentRNA}\) can only solve~\(48\%\)~of~\(\texttt{EteRNA100}\)'s targets, which is also a clear limitation. For the EAs \texttt{ERD} and \texttt{MODENA}, none of them can solve more than~\(65\%\)~of~\(\texttt{EteRNA100}\) using the Turner2004 energy parameter sets.  In the next chapter, we will introduce a simple evolutionary algorithm that allows improving the existing EA tools.
%*****************************************
%*****************************************
%*****************************************
%*****************************************
%*****************************************
